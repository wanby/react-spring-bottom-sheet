{"version":3,"file":"index.modern.js","sources":["../src/hooks/useLayoutEffect.tsx","../src/hooks/body-scroll-lock.ts","../src/utils.ts","../src/hooks/useSnapPoints.tsx","../src/machines/overlay.ts","../src/BottomSheet.tsx","../src/hooks/useReady.tsx","../src/hooks/useSpring.tsx","../src/hooks/useReducedMotion.tsx","../src/hooks/useScrollLock.tsx","../src/hooks/useAriaHider.tsx","../src/hooks/useFocusTrap.tsx","../src/hooks/useSpringInterpolations.tsx","../src/index.tsx"],"sourcesContent":["import { useEffect, useLayoutEffect as useLayoutEffectSafely } from 'react'\r\n\r\n// Ensure the name used in components is useLayoutEffect so the eslint react hooks plugin works\r\nexport const useLayoutEffect =\r\n  typeof window !== 'undefined' ? useLayoutEffectSafely : useEffect\r\n","// @flow\r\n// Adopted and modified solution from Bohdan Didukh (2017)\r\n// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi\r\n\r\n// Modified from https://github.com/willmcpo/body-scroll-lock\r\n\r\nexport interface BodyScrollOptions {\r\n    reserveScrollBarGap?: boolean;\r\n    allowTouchMove?: (el: any) => boolean;\r\n}\r\n\r\ninterface Lock {\r\n    targetElement: any;\r\n    options: BodyScrollOptions;\r\n}\r\n\r\n// Older browsers don't support event options, feature detect it.\r\nlet hasPassiveEvents = false;\r\nif (typeof window !== 'undefined') {\r\n    const passiveTestOptions: any = {\r\n        get passive() {\r\n            hasPassiveEvents = true;\r\n            return undefined;\r\n        },\r\n    };\r\n    window.addEventListener('testPassive', null, passiveTestOptions);\r\n    window.removeEventListener('testPassive', null, passiveTestOptions);\r\n}\r\n\r\nconst isIosDevice =\r\n    typeof window !== 'undefined' &&\r\n    window.navigator &&\r\n    window.navigator.platform &&\r\n    (/iP(ad|hone|od)/.test(window.navigator.platform) ||\r\n        (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1));\r\ntype HandleScrollEvent = TouchEvent;\r\n\r\nlet locks: Array<Lock> = [];\r\nlet documentListenerAdded: boolean = false;\r\nlet initialClientY: number = -1;\r\nlet previousBodyOverflowSetting;\r\nlet previousBodyPaddingRight;\r\n\r\n// returns true if `el` should be allowed to receive touchmove events.\r\nconst allowTouchMove = (el: EventTarget): boolean =>\r\n    locks.some(lock => {\r\n        if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    });\r\n\r\nconst preventDefault = (rawEvent: HandleScrollEvent): boolean => {\r\n    const e = rawEvent || window.event;\r\n\r\n    // For the case whereby consumers adds a touchmove event listener to document.\r\n    // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\r\n    // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\r\n    // the touchmove event on document will break.\r\n    if (allowTouchMove(e.target)) {\r\n        return true;\r\n    }\r\n\r\n    // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\r\n    if ((e as any).touches.length > 1) return true;\r\n\r\n    if (e.preventDefault) e.preventDefault();\r\n\r\n    return false;\r\n};\r\n\r\nconst setOverflowHidden = (options?: BodyScrollOptions) => {\r\n    // If previousBodyPaddingRight is already set, don't set it again.\r\n    if (previousBodyPaddingRight === undefined) {\r\n        const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;\r\n        const scrollBarGap = window.innerWidth - document.documentElement.clientWidth;\r\n\r\n        if (reserveScrollBarGap && scrollBarGap > 0) {\r\n            const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10);\r\n            previousBodyPaddingRight = document.body.style.paddingRight;\r\n            document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`;\r\n        }\r\n    }\r\n\r\n    // If previousBodyOverflowSetting is already set, don't set it again.\r\n    if (previousBodyOverflowSetting === undefined) {\r\n        previousBodyOverflowSetting = document.body.style.overflow;\r\n        document.body.style.overflow = 'hidden';\r\n    }\r\n};\r\n\r\nconst restoreOverflowSetting = () => {\r\n    if (previousBodyPaddingRight !== undefined) {\r\n        document.body.style.paddingRight = previousBodyPaddingRight;\r\n\r\n        // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\r\n        // can be set again.\r\n        previousBodyPaddingRight = undefined;\r\n    }\r\n\r\n    if (previousBodyOverflowSetting !== undefined) {\r\n        document.body.style.overflow = previousBodyOverflowSetting;\r\n\r\n        // Restore previousBodyOverflowSetting to undefined\r\n        // so setOverflowHidden knows it can be set again.\r\n        previousBodyOverflowSetting = undefined;\r\n    }\r\n};\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\r\nconst isTargetElementTotallyScrolled = (targetElement: any): boolean =>\r\n    targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;\r\n\r\nconst handleScroll = (event: HandleScrollEvent, targetElement: any): boolean => {\r\n    const clientY = event.targetTouches[0].clientY - initialClientY;\r\n\r\n    if (allowTouchMove(event.target) && ((targetElement.scrollTop !== 0 && clientY > 0) || (!isTargetElementTotallyScrolled(targetElement) && clientY < 0))) {\r\n        return false;\r\n    }\r\n\r\n    if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\r\n        // element is at the top of its scroll.\r\n        return preventDefault(event);\r\n    }\r\n\r\n    if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\r\n        // element is at the bottom of its scroll.\r\n        return preventDefault(event);\r\n    }\r\n\r\n    event.stopPropagation();\r\n    return true;\r\n};\r\n\r\nexport const disableBodyScroll = (targetElement: any, options?: BodyScrollOptions): void => {\r\n    // targetElement must be provided\r\n    if (!targetElement) {\r\n        // eslint-disable-next-line no-console\r\n        console.error(\r\n            'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\r\n        );\r\n        return;\r\n    }\r\n\r\n    // disableBodyScroll must not have been called on this targetElement before\r\n    if (locks.some(lock => lock.targetElement === targetElement)) {\r\n        return;\r\n    }\r\n\r\n    const lock = {\r\n        targetElement,\r\n        options: options || {},\r\n    };\r\n\r\n    locks = [...locks, lock];\r\n\r\n    if (isIosDevice) {\r\n        targetElement.ontouchstart = (event: HandleScrollEvent) => {\r\n            if (event.targetTouches.length === 1) {\r\n                // detect single touch.\r\n                initialClientY = event.targetTouches[0].clientY;\r\n            }\r\n        };\r\n        targetElement.ontouchmove = (event: HandleScrollEvent) => {\r\n            if (event.targetTouches.length === 1) {\r\n                // detect single touch.\r\n                handleScroll(event, targetElement);\r\n            }\r\n        };\r\n\r\n        if (!documentListenerAdded) {\r\n            document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);\r\n            documentListenerAdded = true;\r\n        }\r\n    } else {\r\n        setOverflowHidden(options);\r\n    }\r\n};\r\n\r\nexport const clearAllBodyScrollLocks = (): void => {\r\n    if (isIosDevice) {\r\n        // Clear all locks ontouchstart/ontouchmove handlers, and the references.\r\n        locks.forEach((lock: Lock) => {\r\n            lock.targetElement.ontouchstart = null;\r\n            lock.targetElement.ontouchmove = null;\r\n        });\r\n\r\n        if (documentListenerAdded) {\r\n            document.removeEventListener('touchmove', preventDefault, (hasPassiveEvents ? { passive: false } : undefined) as any);\r\n            documentListenerAdded = false;\r\n        }\r\n\r\n        // Reset initial clientY.\r\n        initialClientY = -1;\r\n    } else {\r\n        restoreOverflowSetting();\r\n    }\r\n\r\n    locks = [];\r\n};\r\n\r\nexport const enableBodyScroll = (targetElement: any): void => {\r\n    if (!targetElement) {\r\n        // eslint-disable-next-line no-console\r\n        console.error(\r\n            'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\r\n        );\r\n        return;\r\n    }\r\n\r\n    locks = locks.filter(lock => lock.targetElement !== targetElement);\r\n\r\n    if (isIosDevice) {\r\n        targetElement.ontouchstart = null;\r\n        targetElement.ontouchmove = null;\r\n\r\n        if (documentListenerAdded && locks.length === 0) {\r\n            document.removeEventListener('touchmove', preventDefault, (hasPassiveEvents ? { passive: false } : undefined) as any);\r\n            documentListenerAdded = false;\r\n        }\r\n    } else if (!locks.length) {\r\n        restoreOverflowSetting();\r\n    }\r\n};","/* eslint-disable no-self-compare */\r\n\r\n// stolen from lodash\r\nexport function clamp(number: number, lower: number, upper: number) {\r\n  number = +number\r\n  lower = +lower\r\n  upper = +upper\r\n  lower = lower === lower ? lower : 0\r\n  upper = upper === upper ? upper : 0\r\n  if (number === number) {\r\n    number = number <= upper ? number : upper\r\n    number = number >= lower ? number : lower\r\n  }\r\n  return number\r\n}\r\n\r\n// Mwahaha easiest way to filter out NaN I ever saw! >:3\r\nexport function deleteNaN(arr) {\r\n  const set = new Set(arr)\r\n  set.delete(NaN)\r\n  return [...set]\r\n}\r\n\r\nexport function roundAndCheckForNaN(unrounded) {\r\n  const rounded = Math.round(unrounded)\r\n  if (Number.isNaN(unrounded)) {\r\n    throw new TypeError(\r\n      'Found a NaN! Check your snapPoints / defaultSnap / snapTo '\r\n    )\r\n  }\r\n\r\n  return rounded\r\n}\r\n\r\n// Validate, sanitize, round and dedupe snap points, as well as extracting the minSnap and maxSnap points\r\nexport function processSnapPoints(unsafeSnaps: number | number[], maxHeight) {\r\n  const safeSnaps = [].concat(unsafeSnaps).map(roundAndCheckForNaN)\r\n\r\n  const snapPointsDedupedSet = safeSnaps.reduce((acc, snapPoint) => {\r\n    acc.add(clamp(snapPoint, 0, maxHeight))\r\n    return acc\r\n  }, new Set<number>())\r\n\r\n  const snapPoints = Array.from(snapPointsDedupedSet)\r\n\r\n  const minSnap = Math.min(...snapPoints)\r\n  if (Number.isNaN(minSnap)) {\r\n    throw new TypeError('minSnap is NaN')\r\n  }\r\n  const maxSnap = Math.max(...snapPoints)\r\n  if (Number.isNaN(maxSnap)) {\r\n    throw new TypeError('maxSnap is NaN')\r\n  }\r\n\r\n  return {\r\n    snapPoints,\r\n    minSnap,\r\n    maxSnap,\r\n  }\r\n}\r\n\r\nexport const debugging =\r\n  process.env.NODE_ENV === 'development' && typeof window !== 'undefined'\r\n    ? window.location.search === '?debug'\r\n    : false\r\n","import React, {\r\n  useCallback,\r\n  useDebugValue,\r\n  useEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from 'react'\r\nimport { ResizeObserver, ResizeObserverEntry } from '@juggle/resize-observer'\r\nimport type { defaultSnapProps, ResizeSource, snapPoints } from '../types'\r\nimport { processSnapPoints, roundAndCheckForNaN } from '../utils'\r\nimport { useReady } from './useReady'\r\nimport { ResizeObserverOptions } from '@juggle/resize-observer/lib/ResizeObserverOptions'\r\nimport { useLayoutEffect } from './useLayoutEffect'\r\n\r\nexport function useSnapPoints({\r\n  contentRef,\r\n  controlledMaxHeight,\r\n  footerEnabled,\r\n  footerRef,\r\n  getSnapPoints,\r\n  headerEnabled,\r\n  headerRef,\r\n  heightRef,\r\n  lastSnapRef,\r\n  ready,\r\n  registerReady,\r\n  resizeSourceRef,\r\n}: {\r\n  contentRef: React.RefObject<Element>\r\n  controlledMaxHeight?: number\r\n  footerEnabled: boolean\r\n  footerRef: React.RefObject<Element>\r\n  getSnapPoints: snapPoints\r\n  headerEnabled: boolean\r\n  headerRef: React.RefObject<Element>\r\n  heightRef: React.RefObject<number>\r\n  lastSnapRef: React.RefObject<number>\r\n  ready: boolean\r\n  registerReady: ReturnType<typeof useReady>['registerReady']\r\n  resizeSourceRef: React.MutableRefObject<ResizeSource>\r\n}) {\r\n  const { maxHeight, minHeight, headerHeight, footerHeight } = useDimensions({\r\n    contentRef: contentRef,\r\n    controlledMaxHeight,\r\n    footerEnabled,\r\n    footerRef,\r\n    headerEnabled,\r\n    headerRef,\r\n    registerReady,\r\n    resizeSourceRef,\r\n  })\r\n\r\n  const { snapPoints, minSnap, maxSnap } = processSnapPoints(\r\n    ready\r\n      ? getSnapPoints({\r\n          height: heightRef.current,\r\n          footerHeight,\r\n          headerHeight,\r\n          minHeight,\r\n          maxHeight,\r\n        })\r\n      : [0],\r\n    maxHeight\r\n  )\r\n  //console.log({ snapPoints, minSnap, maxSnap })\r\n\r\n  // @TODO investigate the gains from memoizing this\r\n  function findSnap(\r\n    numberOrCallback: number | ((state: defaultSnapProps) => number)\r\n  ) {\r\n    let unsafeSearch: number\r\n    if (typeof numberOrCallback === 'function') {\r\n      unsafeSearch = numberOrCallback({\r\n        footerHeight,\r\n        headerHeight,\r\n        height: heightRef.current,\r\n        minHeight,\r\n        maxHeight,\r\n        snapPoints,\r\n        lastSnap: lastSnapRef.current,\r\n      })\r\n    } else {\r\n      unsafeSearch = numberOrCallback\r\n    }\r\n    const querySnap = roundAndCheckForNaN(unsafeSearch)\r\n    return snapPoints.reduce(\r\n      (prev, curr) =>\r\n        Math.abs(curr - querySnap) < Math.abs(prev - querySnap) ? curr : prev,\r\n      minSnap\r\n    )\r\n  }\r\n\r\n  useDebugValue(`minSnap: ${minSnap}, maxSnap:${maxSnap}`)\r\n\r\n  return { minSnap, maxSnap, findSnap, maxHeight }\r\n}\r\n\r\nfunction useDimensions({\r\n  contentRef,\r\n  controlledMaxHeight,\r\n  footerEnabled,\r\n  footerRef,\r\n  headerEnabled,\r\n  headerRef,\r\n  registerReady,\r\n  resizeSourceRef,\r\n}: {\r\n  contentRef: React.RefObject<Element>\r\n  controlledMaxHeight?: number\r\n  footerEnabled: boolean\r\n  footerRef: React.RefObject<Element>\r\n  headerEnabled: boolean\r\n  headerRef: React.RefObject<Element>\r\n  registerReady: ReturnType<typeof useReady>['registerReady']\r\n  resizeSourceRef: React.MutableRefObject<ResizeSource>\r\n}) {\r\n  const setReady = useMemo(() => registerReady('contentHeight'), [\r\n    registerReady,\r\n  ])\r\n  const maxHeight = useMaxHeight(\r\n    controlledMaxHeight,\r\n    registerReady,\r\n    resizeSourceRef\r\n  )\r\n\r\n  // @TODO probably better to forward props instead of checking refs to decide if it's enabled\r\n  const headerHeight = useElementSizeObserver(headerRef, {\r\n    label: 'headerHeight',\r\n    enabled: headerEnabled,\r\n    resizeSourceRef,\r\n  })\r\n  const contentHeight = useElementSizeObserver(contentRef, {\r\n    label: 'contentHeight',\r\n    enabled: true,\r\n    resizeSourceRef,\r\n  })\r\n  const footerHeight = useElementSizeObserver(footerRef, {\r\n    label: 'footerHeight',\r\n    enabled: footerEnabled,\r\n    resizeSourceRef,\r\n  })\r\n  const minHeight =\r\n    Math.min(maxHeight - headerHeight - footerHeight, contentHeight) +\r\n    headerHeight +\r\n    footerHeight\r\n\r\n  useDebugValue(`minHeight: ${minHeight}`)\r\n\r\n  const ready = contentHeight > 0\r\n  useEffect(() => {\r\n    if (ready) {\r\n      setReady()\r\n    }\r\n  }, [ready, setReady])\r\n\r\n  return {\r\n    maxHeight,\r\n    minHeight,\r\n    headerHeight,\r\n    footerHeight,\r\n  }\r\n}\r\n\r\nconst observerOptions: ResizeObserverOptions = {\r\n  // Respond to changes to padding, happens often on iOS when using env(safe-area-inset-bottom)\r\n  // And the user hides or shows the Safari browser toolbar\r\n  box: 'border-box',\r\n}\r\n/**\r\n * Hook for determining the size of an element using the Resize Observer API.\r\n *\r\n * @param ref - A React ref to an element\r\n */\r\nfunction useElementSizeObserver(\r\n  ref: React.RefObject<Element>,\r\n  {\r\n    label,\r\n    enabled,\r\n    resizeSourceRef,\r\n  }: {\r\n    label: string\r\n    enabled: boolean\r\n    resizeSourceRef: React.MutableRefObject<ResizeSource>\r\n  }\r\n): number {\r\n  let [size, setSize] = useState(0)\r\n\r\n  useDebugValue(`${label}: ${size}`)\r\n\r\n  const handleResize = useCallback(\r\n    (entries: ResizeObserverEntry[]) => {\r\n      // we only observe one element, so accessing the first entry here is fine\r\n      setSize(entries[0].borderBoxSize[0].blockSize)\r\n      resizeSourceRef.current = 'element'\r\n    },\r\n    [resizeSourceRef]\r\n  )\r\n\r\n  useLayoutEffect(() => {\r\n    if (!ref.current || !enabled) {\r\n      return\r\n    }\r\n\r\n    const resizeObserver = new ResizeObserver(handleResize)\r\n    resizeObserver.observe(ref.current, observerOptions)\r\n\r\n    return () => {\r\n      resizeObserver.disconnect()\r\n    }\r\n  }, [ref, handleResize, enabled])\r\n\r\n  return enabled ? size : 0\r\n}\r\n\r\n// Blazingly keep track of the current viewport height without blocking the thread, keeping that sweet 60fps on smartphones\r\nfunction useMaxHeight(\r\n  controlledMaxHeight,\r\n  registerReady: ReturnType<typeof useReady>['registerReady'],\r\n  resizeSourceRef: React.MutableRefObject<ResizeSource>\r\n) {\r\n  const setReady = useMemo(() => registerReady('maxHeight'), [registerReady])\r\n  const [maxHeight, setMaxHeight] = useState(() =>\r\n    roundAndCheckForNaN(controlledMaxHeight) || typeof window !== 'undefined'\r\n      ? window.innerHeight\r\n      : 0\r\n  )\r\n  const ready = maxHeight > 0\r\n  const raf = useRef(0)\r\n\r\n  useDebugValue(controlledMaxHeight ? 'controlled' : 'auto')\r\n\r\n  useEffect(() => {\r\n    if (ready) {\r\n      setReady()\r\n    }\r\n  }, [ready, setReady])\r\n\r\n  useLayoutEffect(() => {\r\n    // Bail if the max height is a controlled prop\r\n    if (controlledMaxHeight) {\r\n      setMaxHeight(roundAndCheckForNaN(controlledMaxHeight))\r\n      resizeSourceRef.current = 'maxheightprop'\r\n\r\n      return\r\n    }\r\n\r\n    const handleResize = () => {\r\n      if (raf.current) {\r\n        // bail to throttle the amount of resize changes\r\n        return\r\n      }\r\n\r\n      // throttle state changes using rAF\r\n      raf.current = requestAnimationFrame(() => {\r\n        setMaxHeight(window.innerHeight)\r\n        resizeSourceRef.current = 'window'\r\n\r\n        raf.current = 0\r\n      })\r\n    }\r\n    window.addEventListener('resize', handleResize)\r\n    setMaxHeight(window.innerHeight)\r\n    resizeSourceRef.current = 'window'\r\n    setReady()\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize)\r\n      cancelAnimationFrame(raf.current)\r\n    }\r\n  }, [controlledMaxHeight, setReady, resizeSourceRef])\r\n\r\n  return maxHeight\r\n}\r\n","import { Machine, assign } from 'xstate'\r\n\r\n// This is the root machine, composing all the other machines and is the brain of the bottom sheet\r\n\r\ninterface OverlayStateSchema {\r\n  states: {\r\n    // the overlay usually starts in the closed position\r\n    closed: {}\r\n    opening: {\r\n      states: {\r\n        // Used to fire off the springStart event\r\n        start: {}\r\n        // Decide how to transition to the open state based on what the initialState is\r\n        transition: {}\r\n        // Fast enter animation, sheet is open by default\r\n        immediately: {\r\n          states: {\r\n            open: {}\r\n            activating: {}\r\n          }\r\n        }\r\n        smoothly: {\r\n          states: {\r\n            // This state only happens when the overlay should start in an open state, instead of animating from the bottom\r\n            // openImmediately: {}\r\n            // visuallyHidden will render the overlay in the open state, but with opacity 0\r\n            // doing this solves two problems:\r\n            // on Android focusing an input element will trigger the softkeyboard to show up, which will change the viewport height\r\n            // on iOS the focus event will break the view by triggering a scrollIntoView event if focus happens while the overlay is below the viewport and body got overflow:hidden\r\n            // by rendering things with opacity 0 we ensure keyboards and scrollIntoView all happen in a way that match up with what the sheet will look like.\r\n            // we can then move it to the opening position below the viewport, and animate it into view without worrying about height changes or scrolling overflow:hidden events\r\n            visuallyHidden: {}\r\n            // In this state we're activating focus traps, scroll locks and more, this will sometimes trigger soft keyboards and scrollIntoView\r\n            // @TODO we might want to add a delay here before proceeding to open, to give android and iOS enough time to adjust the viewport when focusing an interactive element\r\n            activating: {}\r\n            // Animates from the bottom\r\n            open: {}\r\n          }\r\n        }\r\n        // Used to fire off the springEnd event\r\n        end: {}\r\n        // And finally we're ready to transition to open\r\n        done: {}\r\n      }\r\n    }\r\n    open: {}\r\n    // dragging responds to user gestures, which may interrupt the opening state, closing state or snapping\r\n    // when interrupting an opening event, it fires onSpringEnd(OPEN) before onSpringStart(DRAG)\r\n    // when interrupting a closing event, it fires onSpringCancel(CLOSE) before onSpringStart(DRAG)\r\n    // when interrupting a dragging event, it fires onSpringCancel(SNAP) before onSpringStart(DRAG)\r\n    dragging: {}\r\n    // snapping happens whenever transitioning to a new snap point, often after dragging\r\n    snapping: {\r\n      states: {\r\n        start: {}\r\n        snappingSmoothly: {}\r\n        end: {}\r\n        done: {}\r\n      }\r\n    }\r\n    resizing: {\r\n      states: {\r\n        start: {}\r\n        resizingSmoothly: {}\r\n        end: {}\r\n        done: {}\r\n      }\r\n    }\r\n    closing: {\r\n      states: {\r\n        start: {}\r\n        deactivating: {}\r\n        closingSmoothly: {}\r\n        end: {}\r\n        done: {}\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ntype OverlayEvent =\r\n  | { type: 'OPEN' }\r\n  | {\r\n      type: 'SNAP'\r\n      payload: {\r\n        y: number\r\n        velocity: number\r\n        source: 'dragging' | 'custom' | string\r\n      }\r\n    }\r\n  | { type: 'CLOSE' }\r\n  | { type: 'DRAG' }\r\n  | { type: 'RESIZE' }\r\n\r\n// The context (extended state) of the machine\r\ninterface OverlayContext {\r\n  initialState: 'OPEN' | 'CLOSED'\r\n}\r\nfunction sleep(ms = 1000) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms))\r\n}\r\n\r\nconst cancelOpen = {\r\n  CLOSE: { target: '#overlay.closing', actions: 'onOpenCancel' },\r\n}\r\nconst openToDrag = {\r\n  DRAG: { target: '#overlay.dragging', actions: 'onOpenEnd' },\r\n}\r\nconst openToResize = {\r\n  RESIZE: { target: '#overlay.resizing', actions: 'onOpenEnd' },\r\n}\r\n\r\nconst initiallyOpen = ({ initialState }) => initialState === 'OPEN'\r\nconst initiallyClosed = ({ initialState }) => initialState === 'CLOSED'\r\n\r\n// Copy paste the machine into https://xstate.js.org/viz/ to make sense of what's going on in here ;)\r\n\r\nexport const overlayMachine = Machine<\r\n  OverlayContext,\r\n  OverlayStateSchema,\r\n  OverlayEvent\r\n>(\r\n  {\r\n    id: 'overlay',\r\n    initial: 'closed',\r\n    context: { initialState: 'CLOSED' },\r\n    states: {\r\n      closed: { on: { OPEN: 'opening', CLOSE: undefined } },\r\n      opening: {\r\n        initial: 'start',\r\n        states: {\r\n          start: {\r\n            invoke: {\r\n              src: 'onOpenStart',\r\n              onDone: 'transition',\r\n            },\r\n          },\r\n          transition: {\r\n            always: [\r\n              { target: 'immediately', cond: 'initiallyOpen' },\r\n              { target: 'smoothly', cond: 'initiallyClosed' },\r\n            ],\r\n          },\r\n          immediately: {\r\n            initial: 'open',\r\n            states: {\r\n              open: {\r\n                invoke: { src: 'openImmediately', onDone: 'activating' },\r\n              },\r\n              activating: {\r\n                invoke: { src: 'activate', onDone: '#overlay.opening.end' },\r\n                on: { ...openToDrag, ...openToResize },\r\n              },\r\n            },\r\n          },\r\n          smoothly: {\r\n            initial: 'visuallyHidden',\r\n            states: {\r\n              visuallyHidden: {\r\n                invoke: { src: 'renderVisuallyHidden', onDone: 'activating' },\r\n              },\r\n              activating: {\r\n                invoke: { src: 'activate', onDone: 'open' },\r\n              },\r\n              open: {\r\n                invoke: { src: 'openSmoothly', onDone: '#overlay.opening.end' },\r\n                on: { ...openToDrag, ...openToResize },\r\n              },\r\n            },\r\n          },\r\n          end: {\r\n            invoke: { src: 'onOpenEnd', onDone: 'done' },\r\n            on: { CLOSE: '#overlay.closing', DRAG: '#overlay.dragging' },\r\n          },\r\n          done: {\r\n            type: 'final',\r\n          },\r\n        },\r\n        on: { ...cancelOpen },\r\n        onDone: 'open',\r\n      },\r\n      open: {\r\n        on: { DRAG: '#overlay.dragging', SNAP: 'snapping', RESIZE: 'resizing' },\r\n      },\r\n      dragging: {\r\n        on: { SNAP: 'snapping' },\r\n      },\r\n      snapping: {\r\n        initial: 'start',\r\n        states: {\r\n          start: {\r\n            invoke: {\r\n              src: 'onSnapStart',\r\n              onDone: 'snappingSmoothly',\r\n            },\r\n            entry: [\r\n              assign({\r\n                // @ts-expect-error\r\n                y: (_, { payload: { y } }) => y,\r\n                velocity: (_, { payload: { velocity } }) => velocity,\r\n                snapSource: (_, { payload: { source = 'custom' } }) => source,\r\n              }),\r\n            ],\r\n          },\r\n          snappingSmoothly: {\r\n            invoke: { src: 'snapSmoothly', onDone: 'end' },\r\n          },\r\n          end: {\r\n            invoke: { src: 'onSnapEnd', onDone: 'done' },\r\n            on: {\r\n              RESIZE: '#overlay.resizing',\r\n              SNAP: '#overlay.snapping',\r\n              CLOSE: '#overlay.closing',\r\n              DRAG: '#overlay.dragging',\r\n            },\r\n          },\r\n          done: { type: 'final' },\r\n        },\r\n        on: {\r\n          SNAP: { target: 'snapping', actions: 'onSnapEnd' },\r\n          RESIZE: { target: '#overlay.resizing', actions: 'onSnapCancel' },\r\n          DRAG: { target: '#overlay.dragging', actions: 'onSnapCancel' },\r\n          CLOSE: { target: '#overlay.closing', actions: 'onSnapCancel' },\r\n        },\r\n        onDone: 'open',\r\n      },\r\n      resizing: {\r\n        initial: 'start',\r\n        states: {\r\n          start: {\r\n            invoke: {\r\n              src: 'onResizeStart',\r\n              onDone: 'resizingSmoothly',\r\n            },\r\n          },\r\n          resizingSmoothly: {\r\n            invoke: { src: 'resizeSmoothly', onDone: 'end' },\r\n          },\r\n          end: {\r\n            invoke: { src: 'onResizeEnd', onDone: 'done' },\r\n            on: {\r\n              SNAP: '#overlay.snapping',\r\n              CLOSE: '#overlay.closing',\r\n              DRAG: '#overlay.dragging',\r\n            },\r\n          },\r\n          done: { type: 'final' },\r\n        },\r\n        on: {\r\n          RESIZE: { target: 'resizing', actions: 'onResizeEnd' },\r\n          SNAP: { target: 'snapping', actions: 'onResizeCancel' },\r\n          DRAG: { target: '#overlay.dragging', actions: 'onResizeCancel' },\r\n          CLOSE: { target: '#overlay.closing', actions: 'onResizeCancel' },\r\n        },\r\n        onDone: 'open',\r\n      },\r\n      closing: {\r\n        initial: 'start',\r\n        states: {\r\n          start: {\r\n            invoke: {\r\n              src: 'onCloseStart',\r\n              onDone: 'deactivating',\r\n            },\r\n            on: { OPEN: { target: '#overlay.open', actions: 'onCloseCancel' } },\r\n          },\r\n          deactivating: {\r\n            invoke: { src: 'deactivate', onDone: 'closingSmoothly' },\r\n          },\r\n          closingSmoothly: {\r\n            invoke: { src: 'closeSmoothly', onDone: 'end' },\r\n          },\r\n          end: {\r\n            invoke: { src: 'onCloseEnd', onDone: 'done' },\r\n            on: {\r\n              OPEN: { target: '#overlay.opening', actions: 'onCloseCancel' },\r\n            },\r\n          },\r\n          done: { type: 'final' },\r\n        },\r\n        on: {\r\n          CLOSE: undefined,\r\n          OPEN: { target: '#overlay.opening', actions: 'onCloseCancel' },\r\n        },\r\n        onDone: 'closed',\r\n      },\r\n    },\r\n    on: {\r\n      CLOSE: 'closing',\r\n    },\r\n  },\r\n  {\r\n    actions: {\r\n      onOpenCancel: (context, event) => {\r\n        console.log('onOpenCancel', { context, event })\r\n      },\r\n      onSnapCancel: (context, event) => {\r\n        console.log('onSnapCancel', { context, event })\r\n      },\r\n      onResizeCancel: (context, event) => {\r\n        console.log('onResizeCancel', { context, event })\r\n      },\r\n      onCloseCancel: (context, event) => {\r\n        console.log('onCloseCancel', { context, event })\r\n      },\r\n      onOpenEnd: (context, event) => {\r\n        console.log('onOpenCancel', { context, event })\r\n      },\r\n      onSnapEnd: (context, event) => {\r\n        console.log('onSnapEnd', { context, event })\r\n      },\r\n      onRezizeEnd: (context, event) => {\r\n        console.log('onRezizeEnd', { context, event })\r\n      },\r\n    },\r\n    services: {\r\n      onSnapStart: async () => {\r\n        await sleep()\r\n      },\r\n      onOpenStart: async () => {\r\n        await sleep()\r\n      },\r\n      onCloseStart: async () => {\r\n        await sleep()\r\n      },\r\n      onResizeStart: async () => {\r\n        await sleep()\r\n      },\r\n      onSnapEnd: async () => {\r\n        await sleep()\r\n      },\r\n      onOpenEnd: async () => {\r\n        await sleep()\r\n      },\r\n      onCloseEnd: async () => {\r\n        await sleep()\r\n      },\r\n      onResizeEnd: async () => {\r\n        await sleep()\r\n      },\r\n      renderVisuallyHidden: async (context, event) => {\r\n        console.group('renderVisuallyHidden')\r\n        console.log({ context, event })\r\n        await sleep()\r\n        console.groupEnd()\r\n      },\r\n      activate: async (context, event) => {\r\n        console.group('activate')\r\n        console.log({ context, event })\r\n        await sleep()\r\n        console.groupEnd()\r\n      },\r\n      deactivate: async (context, event) => {\r\n        console.group('deactivate')\r\n        console.log({ context, event })\r\n        await sleep()\r\n        console.groupEnd()\r\n      },\r\n      openSmoothly: async (context, event) => {\r\n        console.group('openSmoothly')\r\n        console.log({ context, event })\r\n        await sleep()\r\n        console.groupEnd()\r\n      },\r\n      openImmediately: async (context, event) => {\r\n        console.group('openImmediately')\r\n        console.log({ context, event })\r\n        await sleep()\r\n        console.groupEnd()\r\n      },\r\n      snapSmoothly: async (context, event) => {\r\n        console.group('snapSmoothly')\r\n        console.log({ context, event })\r\n        await sleep()\r\n        console.groupEnd()\r\n      },\r\n      resizeSmoothly: async (context, event) => {\r\n        console.group('resizeSmoothly')\r\n        console.log({ context, event })\r\n        await sleep()\r\n        console.groupEnd()\r\n      },\r\n      closeSmoothly: async (context, event) => {\r\n        console.group('closeSmoothly')\r\n        console.log({ context, event })\r\n        await sleep()\r\n        console.groupEnd()\r\n      },\r\n    },\r\n    guards: { initiallyClosed, initiallyOpen },\r\n  }\r\n)\r\n","//\r\n// In order to greatly reduce complexity this component is designed to always transition to open on mount, and then\r\n// transition to a closed state later. This ensures that all memory used to keep track of animation and gesture state\r\n// can be reclaimed after the sheet is closed and then unmounted.\r\n// It also ensures that when transitioning to open on mount the state is always clean, not affected by previous states that could\r\n// cause race conditions.\r\n\r\nimport { useMachine } from '@xstate/react'\r\nimport React, {\r\n  useCallback,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useRef,\r\n} from 'react'\r\nimport { animated, config } from 'react-spring'\r\nimport { rubberbandIfOutOfBounds, useDrag } from 'react-use-gesture'\r\nimport {\r\n  useAriaHider,\r\n  useFocusTrap,\r\n  useLayoutEffect,\r\n  useReady,\r\n  useReducedMotion,\r\n  useScrollLock,\r\n  useSnapPoints,\r\n  useSpring,\r\n  useSpringInterpolations,\r\n} from './hooks'\r\nimport { overlayMachine } from './machines/overlay'\r\nimport type {\r\n  defaultSnapProps,\r\n  Props,\r\n  RefHandles,\r\n  ResizeSource,\r\n  SnapPointProps,\r\n} from './types'\r\nimport { debugging } from './utils'\r\n\r\nconst { tension, friction } = config.default\r\n\r\n// @TODO implement AbortController to deal with race conditions\r\n\r\n// @TODO rename to SpringBottomSheet and allow userland to import it directly, for those who want maximum control and minimal bundlesize\r\nexport const BottomSheet = React.forwardRef<\r\n  RefHandles,\r\n  {\r\n    initialState: 'OPEN' | 'CLOSED'\r\n    lastSnapRef: React.MutableRefObject<number | null>\r\n  } & Props\r\n>(function BottomSheetInternal(\r\n  {\r\n    children,\r\n    sibling,\r\n    className,\r\n    topOffset,\r\n    springConfig,\r\n    ignoreLockClasses,\r\n    footer,\r\n    header,\r\n    open: _open,\r\n    initialState,\r\n    lastSnapRef,\r\n    initialFocusRef,\r\n    onDismiss,\r\n    maxHeight: controlledMaxHeight,\r\n    defaultSnap: getDefaultSnap = _defaultSnap,\r\n    snapPoints: getSnapPoints = _snapPoints,\r\n    blocking = true,\r\n    scrollLocking = true,\r\n    style,\r\n    onSpringStart,\r\n    onSpringCancel,\r\n    onSpringEnd,\r\n    reserveScrollBarGap = blocking,\r\n    ...props\r\n  },\r\n  forwardRef\r\n) {\r\n  // Before any animations can start we need to measure a few things, like the viewport and the dimensions of content, and header + footer if they exist\r\n  // @TODO make ready its own state perhaps, before open or closed\r\n  const { ready, registerReady } = useReady()\r\n\r\n  // Controls the drag handler, used by spring operations that happen outside the render loop in React\r\n  const canDragRef = useRef(false)\r\n\r\n  // This way apps don't have to remember to wrap their callbacks in useCallback to avoid breaking the sheet\r\n  const onSpringStartRef = useRef(onSpringStart)\r\n  const onSpringCancelRef = useRef(onSpringCancel)\r\n  const onSpringEndRef = useRef(onSpringEnd)\r\n  useEffect(() => {\r\n    onSpringStartRef.current = onSpringStart\r\n    onSpringCancelRef.current = onSpringCancel\r\n    onSpringEndRef.current = onSpringEnd\r\n  }, [onSpringCancel, onSpringStart, onSpringEnd])\r\n\r\n  // Behold, the engine of it all!\r\n  const [spring, set] = useSpring()\r\n\r\n  const containerRef = useRef<HTMLDivElement>(null)\r\n  const scrollRef = useRef<HTMLDivElement>(null)\r\n  const contentRef = useRef<HTMLDivElement>(null)\r\n  const headerRef = useRef<HTMLDivElement>(null)\r\n  const footerRef = useRef<HTMLDivElement>(null)\r\n  const overlayRef = useRef<HTMLDivElement | null>(null)\r\n\r\n  // Keeps track of the current height, or the height transitioning to\r\n  const heightRef = useRef(0)\r\n  const resizeSourceRef = useRef<ResizeSource>()\r\n\r\n  const prefersReducedMotion = useReducedMotion()\r\n\r\n  // \"Plugins\" huhuhu\r\n  const scrollLockRef = useScrollLock({\r\n    targetRef: scrollRef,\r\n    enabled: ready && scrollLocking,\r\n    reserveScrollBarGap,\r\n    ignoreLockClasses: !!ignoreLockClasses ? Array.isArray(ignoreLockClasses) ? ignoreLockClasses : [ignoreLockClasses] : [],\r\n  })\r\n  const ariaHiderRef = useAriaHider({\r\n    targetRef: containerRef,\r\n    enabled: ready && blocking,\r\n  })\r\n  const focusTrapRef = useFocusTrap({\r\n    targetRef: containerRef,\r\n    fallbackRef: overlayRef,\r\n    initialFocusRef,\r\n    enabled: ready && blocking,\r\n  })\r\n\r\n  const { minSnap, maxSnap, maxHeight, findSnap } = useSnapPoints({\r\n    contentRef,\r\n    controlledMaxHeight,\r\n    footerEnabled: !!footer,\r\n    footerRef,\r\n    getSnapPoints,\r\n    headerEnabled: header !== false,\r\n    headerRef,\r\n    heightRef,\r\n    lastSnapRef,\r\n    ready,\r\n    registerReady,\r\n    resizeSourceRef,\r\n  })\r\n\r\n  // Setup refs that are used in cases where full control is needed over when a side effect is executed\r\n  const maxHeightRef = useRef(maxHeight)\r\n  const minSnapRef = useRef(minSnap)\r\n  const maxSnapRef = useRef(maxSnap)\r\n  const findSnapRef = useRef(findSnap)\r\n  const defaultSnapRef = useRef(0)\r\n  const topOffsetRef = useRef(topOffset || 0)\r\n  // Sync the refs with current state, giving the spring full control over when to respond to changes\r\n  useLayoutEffect(() => {\r\n    maxHeightRef.current = maxHeight\r\n    maxSnapRef.current = maxSnap\r\n    minSnapRef.current = minSnap\r\n    findSnapRef.current = findSnap\r\n    defaultSnapRef.current = findSnap(getDefaultSnap)\r\n  }, [findSnap, getDefaultSnap, maxHeight, maxSnap, minSnap])\r\n\r\n  // New utility for using events safely\r\n  const asyncSet = useCallback<typeof set>(\r\n    // @ts-expect-error\r\n    ({ onRest, config: { velocity = 1, ...config } = {}, ...opts }) =>\r\n      new Promise((resolve) =>\r\n        set({\r\n          ...opts,\r\n          config: {\r\n            velocity,\r\n            ...config,\r\n            // @see https://springs.pomb.us\r\n            mass: 1,\r\n            // \"stiffness\"\r\n            tension,\r\n            // \"damping\"\r\n            friction: Math.max(\r\n              friction,\r\n              friction + (friction - friction * velocity)\r\n            ),\r\n\r\n            ...springConfig,\r\n          },\r\n          onRest: (...args) => {\r\n            resolve(...args)\r\n            onRest?.(...args)\r\n          },\r\n        })\r\n      ),\r\n    [set]\r\n  )\r\n  const [current, send] = useMachine(overlayMachine, {\r\n    devTools: debugging,\r\n    actions: {\r\n      onOpenCancel: useCallback(\r\n        () => onSpringCancelRef.current?.({ type: 'OPEN' }),\r\n        []\r\n      ),\r\n      onSnapCancel: useCallback(\r\n        (context) =>\r\n          onSpringCancelRef.current?.({\r\n            type: 'SNAP',\r\n            source: context.snapSource,\r\n          }),\r\n        []\r\n      ),\r\n      onCloseCancel: useCallback(\r\n        () => onSpringCancelRef.current?.({ type: 'CLOSE' }),\r\n        []\r\n      ),\r\n      onResizeCancel: useCallback(\r\n        () =>\r\n          onSpringCancelRef.current?.({\r\n            type: 'RESIZE',\r\n            source: resizeSourceRef.current,\r\n          }),\r\n        []\r\n      ),\r\n      onOpenEnd: useCallback(\r\n        () => onSpringEndRef.current?.({ type: 'OPEN' }),\r\n        []\r\n      ),\r\n      onSnapEnd: useCallback(\r\n        (context, event) =>\r\n          onSpringEndRef.current?.({\r\n            type: 'SNAP',\r\n            source: context.snapSource,\r\n          }),\r\n        []\r\n      ),\r\n      onResizeEnd: useCallback(\r\n        () =>\r\n          onSpringEndRef.current?.({\r\n            type: 'RESIZE',\r\n            source: resizeSourceRef.current,\r\n          }),\r\n        []\r\n      ),\r\n    },\r\n    context: { initialState },\r\n    services: {\r\n      onSnapStart: useCallback(\r\n        async (context, event) =>\r\n          onSpringStartRef.current?.({\r\n            type: 'SNAP',\r\n            source: event.payload.source || 'custom',\r\n          }),\r\n        []\r\n      ),\r\n      onOpenStart: useCallback(\r\n        async () => onSpringStartRef.current?.({ type: 'OPEN' }),\r\n        []\r\n      ),\r\n      onCloseStart: useCallback(\r\n        async () => onSpringStartRef.current?.({ type: 'CLOSE' }),\r\n        []\r\n      ),\r\n      onResizeStart: useCallback(\r\n        async () =>\r\n          onSpringStartRef.current?.({\r\n            type: 'RESIZE',\r\n            source: resizeSourceRef.current,\r\n          }),\r\n        []\r\n      ),\r\n      onSnapEnd: useCallback(\r\n        async (context, event) =>\r\n          onSpringEndRef.current?.({\r\n            type: 'SNAP',\r\n            source: context.snapSource,\r\n          }),\r\n        []\r\n      ),\r\n      onOpenEnd: useCallback(\r\n        async () => onSpringEndRef.current?.({ type: 'OPEN' }),\r\n        []\r\n      ),\r\n      onCloseEnd: useCallback(\r\n        async () => onSpringEndRef.current?.({ type: 'CLOSE' }),\r\n        []\r\n      ),\r\n      onResizeEnd: useCallback(\r\n        async () =>\r\n          onSpringEndRef.current?.({\r\n            type: 'RESIZE',\r\n            source: resizeSourceRef.current,\r\n          }),\r\n        []\r\n      ),\r\n      renderVisuallyHidden: useCallback(\r\n        async (context, event) => {\r\n          await asyncSet({\r\n            y: defaultSnapRef.current,\r\n            ready: 0,\r\n            maxHeight: maxHeightRef.current,\r\n            maxSnap: maxSnapRef.current,\r\n            // Using defaultSnapRef instead of minSnapRef to avoid animating `height` on open\r\n            minSnap: defaultSnapRef.current,\r\n            immediate: true,\r\n            topOffset: topOffsetRef.current,\r\n          })\r\n        },\r\n        [asyncSet]\r\n      ),\r\n      activate: useCallback(\r\n        async (context, event) => {\r\n          canDragRef.current = true\r\n          await Promise.all([\r\n            scrollLockRef.current.activate(),\r\n            focusTrapRef.current.activate(),\r\n            ariaHiderRef.current.activate(),\r\n          ])\r\n        },\r\n        [ariaHiderRef, focusTrapRef, scrollLockRef]\r\n      ),\r\n      deactivate: useCallback(async () => {\r\n        scrollLockRef.current.deactivate()\r\n        focusTrapRef.current.deactivate()\r\n        ariaHiderRef.current.deactivate()\r\n        canDragRef.current = false\r\n      }, [ariaHiderRef, focusTrapRef, scrollLockRef]),\r\n      openImmediately: useCallback(async () => {\r\n        heightRef.current = defaultSnapRef.current\r\n        await asyncSet({\r\n          y: defaultSnapRef.current,\r\n          ready: 1,\r\n          maxHeight: maxHeightRef.current,\r\n          maxSnap: maxSnapRef.current,\r\n          // Using defaultSnapRef instead of minSnapRef to avoid animating `height` on open\r\n          minSnap: defaultSnapRef.current,\r\n          immediate: true,\r\n          topOffset: topOffsetRef.current\r\n        })\r\n      }, [asyncSet]),\r\n      openSmoothly: useCallback(async () => {\r\n        await asyncSet({\r\n          y: 0,\r\n          ready: 1,\r\n          maxHeight: maxHeightRef.current,\r\n          maxSnap: maxSnapRef.current,\r\n          // Using defaultSnapRef instead of minSnapRef to avoid animating `height` on open\r\n          minSnap: defaultSnapRef.current,\r\n          immediate: true,\r\n          topOffset: topOffsetRef.current\r\n        })\r\n\r\n        heightRef.current = defaultSnapRef.current\r\n\r\n        await asyncSet({\r\n          y: defaultSnapRef.current,\r\n          ready: 1,\r\n          maxHeight: maxHeightRef.current,\r\n          maxSnap: maxSnapRef.current,\r\n          // Using defaultSnapRef instead of minSnapRef to avoid animating `height` on open\r\n          minSnap: defaultSnapRef.current,\r\n          immediate: prefersReducedMotion.current,\r\n          topOffset: topOffsetRef.current,\r\n        })\r\n      }, [asyncSet, prefersReducedMotion]),\r\n      snapSmoothly: useCallback(\r\n        async (context, event) => {\r\n          const snap = findSnapRef.current(context.y)\r\n          heightRef.current = snap\r\n          lastSnapRef.current = snap\r\n          await asyncSet({\r\n            y: snap,\r\n            ready: 1,\r\n            maxHeight: maxHeightRef.current,\r\n            maxSnap: maxSnapRef.current,\r\n            minSnap: minSnapRef.current,\r\n            immediate: prefersReducedMotion.current,\r\n            topOffset: topOffsetRef.current,\r\n            config: { velocity: context.velocity },\r\n          })\r\n        },\r\n        [asyncSet, lastSnapRef, prefersReducedMotion]\r\n      ),\r\n      resizeSmoothly: useCallback(async () => {\r\n        const snap = findSnapRef.current(heightRef.current)\r\n        heightRef.current = snap\r\n        lastSnapRef.current = snap\r\n        await asyncSet({\r\n          y: snap,\r\n          ready: 1,\r\n          maxHeight: maxHeightRef.current,\r\n          maxSnap: maxSnapRef.current,\r\n          minSnap: minSnapRef.current,\r\n          topOffset: topOffsetRef.current,\r\n          immediate:\r\n            resizeSourceRef.current === 'element'\r\n              ? prefersReducedMotion.current\r\n              : true,\r\n        })\r\n      }, [asyncSet, lastSnapRef, prefersReducedMotion]),\r\n      closeSmoothly: useCallback(\r\n        async (context, event) => {\r\n          // Avoid animating the height property on close and stay within FLIP bounds by upping the minSnap\r\n          asyncSet({\r\n            minSnap: heightRef.current,\r\n            immediate: true,\r\n          })\r\n\r\n          heightRef.current = 0\r\n\r\n          await asyncSet({\r\n            y: 0,\r\n            maxHeight: maxHeightRef.current,\r\n            maxSnap: maxSnapRef.current,\r\n            immediate: prefersReducedMotion.current,\r\n          })\r\n\r\n          await asyncSet({ ready: 0, immediate: true })\r\n        },\r\n        [asyncSet, prefersReducedMotion]\r\n      ),\r\n    },\r\n  })\r\n\r\n  useEffect(() => {\r\n    if (!ready) return\r\n\r\n    if (_open) {\r\n      send('OPEN')\r\n    } else {\r\n      send('CLOSE')\r\n    }\r\n  }, [_open, send, ready])\r\n  useLayoutEffect(() => {\r\n    // Adjust the height whenever the snap points are changed due to resize events\r\n    if (maxHeight || maxSnap || minSnap) {\r\n      send('RESIZE')\r\n    }\r\n  }, [maxHeight, maxSnap, minSnap, send])\r\n  useEffect(\r\n    () => () => {\r\n      // Ensure effects are cleaned up on unmount, in case they're not cleaned up otherwise\r\n      scrollLockRef.current.deactivate()\r\n      focusTrapRef.current.deactivate()\r\n      ariaHiderRef.current.deactivate()\r\n    },\r\n    [ariaHiderRef, focusTrapRef, scrollLockRef]\r\n  )\r\n\r\n  useImperativeHandle(\r\n    forwardRef,\r\n    () => ({\r\n      snapTo: (numberOrCallback, { velocity = 1, source = 'custom' } = {}) => {\r\n        send('SNAP', {\r\n          payload: {\r\n            y: findSnapRef.current(numberOrCallback),\r\n            velocity,\r\n            source,\r\n          },\r\n        })\r\n      },\r\n      get height() {\r\n        return heightRef.current\r\n      },\r\n    }),\r\n    [send]\r\n  )\r\n\r\n  const handleDrag = ({\r\n    args: [{ closeOnTap = false } = {}] = [],\r\n    cancel,\r\n    direction: [, direction],\r\n    down,\r\n    first,\r\n    last,\r\n    memo = spring.y.getValue() as number,\r\n    movement: [, _my],\r\n    tap,\r\n    velocity,\r\n  }) => {\r\n    const my = _my * -1\r\n\r\n    // Cancel the drag operation if the canDrag state changed\r\n    if (!canDragRef.current) {\r\n      console.log('handleDrag cancelled dragging because canDragRef is false')\r\n      cancel()\r\n      return memo\r\n    }\r\n\r\n    if (onDismiss && closeOnTap && tap) {\r\n      cancel()\r\n      // Runs onDismiss in a timeout to avoid tap events on the backdrop from triggering click events on elements underneath\r\n      setTimeout(() => onDismiss(), 0)\r\n      return memo\r\n    }\r\n\r\n    // Filter out taps\r\n    if (tap) {\r\n      return memo\r\n    }\r\n\r\n    const rawY = memo + my\r\n    const predictedDistance = my * velocity\r\n    const predictedY = Math.max(\r\n      minSnapRef.current,\r\n      Math.min(maxSnapRef.current, rawY + predictedDistance * 2)\r\n    )\r\n\r\n    if (\r\n      !down &&\r\n      onDismiss &&\r\n      direction > 0 &&\r\n      rawY + predictedDistance < minSnapRef.current / 2\r\n    ) {\r\n      cancel()\r\n      onDismiss()\r\n      return memo\r\n    }\r\n\r\n    let newY = down\r\n      ? // @TODO figure out a better way to deal with rubberband overshooting if min and max have the same value\r\n        !onDismiss && minSnapRef.current === maxSnapRef.current\r\n        ? rawY < minSnapRef.current\r\n          ? rubberbandIfOutOfBounds(\r\n              rawY,\r\n              minSnapRef.current,\r\n              maxSnapRef.current * 2,\r\n              0.85\r\n            )\r\n          : rubberbandIfOutOfBounds(\r\n              rawY,\r\n              minSnapRef.current / 2,\r\n              maxSnapRef.current,\r\n              0.85\r\n            )\r\n        : rubberbandIfOutOfBounds(\r\n            rawY,\r\n            onDismiss ? 0 : minSnapRef.current,\r\n            maxSnapRef.current,\r\n            0.85\r\n          )\r\n      : predictedY\r\n\r\n    if (first) {\r\n      send('DRAG')\r\n    }\r\n\r\n    if (last) {\r\n      send('SNAP', {\r\n        payload: {\r\n          y: newY,\r\n          velocity: velocity > 0.05 ? velocity : 1,\r\n          source: 'dragging',\r\n        },\r\n      })\r\n\r\n      return memo\r\n    }\r\n\r\n    // @TODO too many rerenders\r\n    //send('DRAG', { y: newY, velocity })\r\n    //*\r\n    set({\r\n      y: newY,\r\n      ready: 1,\r\n      maxHeight: maxHeightRef.current,\r\n      maxSnap: maxSnapRef.current,\r\n      minSnap: minSnapRef.current,\r\n      topOffset: topOffsetRef.current,\r\n      immediate: true,\r\n      config: { velocity },\r\n    })\r\n    // */\r\n\r\n    return memo\r\n  }\r\n\r\n  const bind = useDrag(handleDrag, {\r\n    filterTaps: true,\r\n  })\r\n\r\n  if (Number.isNaN(maxSnapRef.current)) {\r\n    throw new TypeError('maxSnapRef is NaN!!')\r\n  }\r\n  if (Number.isNaN(minSnapRef.current)) {\r\n    throw new TypeError('minSnapRef is NaN!!')\r\n  }\r\n\r\n  const interpolations = useSpringInterpolations({ spring })\r\n\r\n  return (\r\n    <animated.div\r\n      {...props}\r\n      data-rsbs-root\r\n      data-rsbs-state={publicStates.find(current.matches)}\r\n      data-rsbs-is-blocking={blocking}\r\n      data-rsbs-is-dismissable={!!onDismiss}\r\n      data-rsbs-has-header={!!header}\r\n      data-rsbs-has-footer={!!footer}\r\n      className={className}\r\n      ref={containerRef}\r\n      style={{\r\n        // spread in the interpolations yeees\r\n        ...interpolations,\r\n        // but allow overriding them/disabling them\r\n        ...style,\r\n        // Not overridable as the \"focus lock with opacity 0\" trick rely on it\r\n        // @TODO the line below only fails on TS <4\r\n        // @ts-ignore\r\n        opacity: spring.ready,\r\n      }}\r\n    >\r\n      {sibling}\r\n      {blocking && (\r\n        <div\r\n          // This component needs to be placed outside bottom-sheet, as bottom-sheet uses transform and thus creates a new context\r\n          // that clips this element to the container, not allowing it to cover the full page.\r\n          key=\"backdrop\"\r\n          data-rsbs-backdrop\r\n          {...bind({ closeOnTap: true })}\r\n        />\r\n      )}\r\n      <div\r\n        key=\"overlay\"\r\n        aria-modal=\"true\"\r\n        role=\"dialog\"\r\n        data-rsbs-overlay\r\n        tabIndex={-1}\r\n        ref={overlayRef}\r\n        onKeyDown={(event) => {\r\n          if (event.key === 'Escape') {\r\n            // Always stop propagation, to avoid weirdness for bottom sheets inside other bottom sheets\r\n            event.stopPropagation()\r\n            if (onDismiss) onDismiss()\r\n          }\r\n        }}\r\n      >\r\n        {header !== false && (\r\n          <div key=\"header\" data-rsbs-header ref={headerRef} {...bind()}>\r\n            {header}\r\n          </div>\r\n        )}\r\n        <div key=\"scroll\" data-rsbs-scroll ref={scrollRef}>\r\n          <div data-rsbs-content ref={contentRef}>\r\n            {children}\r\n          </div>\r\n        </div>\r\n        {footer && (\r\n          <div key=\"footer\" ref={footerRef} data-rsbs-footer {...bind()}>\r\n            {footer}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </animated.div>\r\n  )\r\n})\r\n\r\n// Used for the data attribute, list over states available to CSS selectors\r\nconst publicStates = [\r\n  'closed',\r\n  'opening',\r\n  'open',\r\n  'closing',\r\n  'dragging',\r\n  'snapping',\r\n  'resizing',\r\n]\r\n\r\n// Default prop values that are callbacks, and it's nice to save some memory and reuse their instances since they're pure\r\nfunction _defaultSnap({ snapPoints, lastSnap }: defaultSnapProps) {\r\n  return lastSnap ?? Math.min(...snapPoints)\r\n}\r\nfunction _snapPoints({ minHeight }: SnapPointProps) {\r\n  return minHeight\r\n}\r\n","// Keeps track of wether everything is good to go or not, in the most efficient way possible\r\n\r\nimport { useCallback, useEffect, useState } from 'react'\r\n\r\nexport function useReady() {\r\n  const [ready, setReady] = useState(false)\r\n  const [readyMap, updateReadyMap] = useState<{ [key: string]: boolean }>({})\r\n\r\n  const registerReady = useCallback((key: string) => {\r\n    console.count(`registerReady:${key}`)\r\n    // Register the check we're gonna wait for until it's ready\r\n    updateReadyMap((ready) => ({ ...ready, [key]: false }))\r\n\r\n    return () => {\r\n      console.count(`setReady:${key}`)\r\n      // Set it to ready\r\n      updateReadyMap((ready) => ({ ...ready, [key]: true }))\r\n    }\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    const states = Object.values(readyMap)\r\n\r\n    if (states.length === 0) {\r\n      console.log('nope nothing registered yet')\r\n      return\r\n    }\r\n\r\n    const isReady = states.every(Boolean)\r\n    console.log('check if we are rready', readyMap, isReady)\r\n    if (isReady) {\r\n      console.warn('ready!')\r\n      setReady(true)\r\n    }\r\n  }, [readyMap])\r\n\r\n  return { ready, registerReady }\r\n}\r\n","import { useSpring as useReactSpring } from 'react-spring'\r\n\r\n// Behold, the engine of it all!\r\n// Put in this file befause it makes it easier to type and I'm lazy! :D\r\n\r\nexport function useSpring() {\r\n  return useReactSpring(() => ({\r\n    y: 0,\r\n    ready: 0,\r\n    maxHeight: 0,\r\n    minSnap: 0,\r\n    maxSnap: 0,\r\n    topOffset: 0,\r\n  }))\r\n}\r\n\r\nexport type Spring = ReturnType<typeof useSpring>[0]\r\nexport type SpringSet = ReturnType<typeof useSpring>[1]\r\n","import { useDebugValue, useEffect, useMemo, useRef } from 'react'\r\n\r\n// @TODO refactor to addEventListener\r\nexport function useReducedMotion() {\r\n  const mql = useMemo(\r\n    () =>\r\n      typeof window !== 'undefined'\r\n        ? window.matchMedia('(prefers-reduced-motion: reduce)')\r\n        : null,\r\n    []\r\n  )\r\n  const ref = useRef(mql?.matches)\r\n\r\n  useDebugValue(ref.current ? 'reduce' : 'no-preference')\r\n\r\n  useEffect(() => {\r\n    const handler = (event) => {\r\n      ref.current = event.matches\r\n    }\r\n    mql?.addListener(handler)\r\n\r\n    return () => mql?.removeListener(handler)\r\n  }, [mql])\r\n\r\n  return ref\r\n}\r\n","import { disableBodyScroll, enableBodyScroll, clearAllBodyScrollLocks } from './body-scroll-lock'\r\nimport { useDebugValue, useEffect, useRef } from 'react'\r\n\r\n/**\r\n * Handle scroll locking to ensure a good dragging experience on Android and iOS.\r\n *\r\n * On iOS the following may happen if scroll isn't locked:\r\n * - When dragging the sheet the background gets dragged at the same time.\r\n * - When dragging the page scroll is also affected, causing the drag to feel buggy and \"slow\".\r\n *\r\n * On Android it causes the chrome toolbar to pop down as you drag down, and hide as you drag up.\r\n * When it's in between two toolbar states it causes the framerate to drop way below 60fps on\r\n * the bottom sheet drag interaction.\r\n */\r\nexport function useScrollLock({\r\n  targetRef,\r\n  enabled,\r\n  reserveScrollBarGap,\r\n  ignoreLockClasses,\r\n}: {\r\n  targetRef: React.RefObject<Element>\r\n  enabled: boolean\r\n  reserveScrollBarGap: boolean,\r\n  ignoreLockClasses: string[],\r\n}) {\r\n  const ref = useRef<{ activate: () => void; deactivate: () => void }>({\r\n    activate: () => {\r\n      throw new TypeError('Tried to activate scroll lock too early')\r\n    },\r\n    deactivate: () => {},\r\n  })\r\n\r\n  useDebugValue(enabled ? 'Enabled' : 'Disabled')\r\n\r\n  useEffect(() => {\r\n    if (!enabled) {\r\n      ref.current.deactivate()\r\n      ref.current = { activate: () => {}, deactivate: () => {} }\r\n      return\r\n    }\r\n\r\n    const target = targetRef.current\r\n    let active = false\r\n\r\n    ref.current = {\r\n      activate: () => {\r\n        if (active) return\r\n        active = true\r\n        clearAllBodyScrollLocks();\r\n        disableBodyScroll(target, {\r\n          allowTouchMove: (el) => {\r\n            // el.closest('[data-body-scroll-lock-ignore]')\r\n            if (ignoreLockClasses.length === 0) return false;\r\n            return ignoreLockClasses.some((className) => {\r\n              return className && className.length && el.closest(`.${className}`)\r\n            })\r\n          },\r\n          reserveScrollBarGap,\r\n        })\r\n      },\r\n      deactivate: () => {\r\n        if (!active) return\r\n        active = false\r\n        enableBodyScroll(target)\r\n      },\r\n    }\r\n  }, [enabled, targetRef, reserveScrollBarGap, ignoreLockClasses])\r\n\r\n  return ref\r\n}\r\n","import React, { useDebugValue, useEffect, useRef } from 'react'\r\n\r\n// Handle hiding and restoring aria-hidden attributes\r\nexport function useAriaHider({\r\n  targetRef,\r\n  enabled,\r\n}: {\r\n  targetRef: React.RefObject<Element>\r\n  enabled: boolean\r\n}) {\r\n  const ref = useRef<{ activate: () => void; deactivate: () => void }>({\r\n    activate: () => {\r\n      throw new TypeError('Tried to activate aria hider too early')\r\n    },\r\n    deactivate: () => {},\r\n  })\r\n\r\n  useDebugValue(enabled ? 'Enabled' : 'Disabled')\r\n\r\n  useEffect(() => {\r\n    if (!enabled) {\r\n      ref.current.deactivate()\r\n      ref.current = { activate: () => {}, deactivate: () => {} }\r\n      return\r\n    }\r\n\r\n    const target = targetRef.current\r\n    let active = false\r\n    let originalValues: (null | string)[] = []\r\n    let rootNodes: Element[] = []\r\n\r\n    ref.current = {\r\n      activate: () => {\r\n        if (active) return\r\n        active = true\r\n\r\n        const parentNode = target.parentNode\r\n\r\n        document.querySelectorAll('body > *').forEach((node) => {\r\n          if (node === parentNode) {\r\n            return\r\n          }\r\n          let attr = node.getAttribute('aria-hidden')\r\n          let alreadyHidden = attr !== null && attr !== 'false'\r\n          if (alreadyHidden) {\r\n            return\r\n          }\r\n          originalValues.push(attr)\r\n          rootNodes.push(node)\r\n          node.setAttribute('aria-hidden', 'true')\r\n        })\r\n      },\r\n      deactivate: () => {\r\n        if (!active) return\r\n        active = false\r\n\r\n        rootNodes.forEach((node, index) => {\r\n          let originalValue = originalValues[index]\r\n          if (originalValue === null) {\r\n            node.removeAttribute('aria-hidden')\r\n          } else {\r\n            node.setAttribute('aria-hidden', originalValue)\r\n          }\r\n        })\r\n        originalValues = []\r\n        rootNodes = []\r\n      },\r\n    }\r\n  }, [targetRef, enabled])\r\n\r\n  return ref\r\n}\r\n","import { createFocusTrap } from 'focus-trap'\r\nimport { useDebugValue, useEffect, useRef } from 'react'\r\n\r\nexport function useFocusTrap({\r\n  targetRef,\r\n  fallbackRef,\r\n  initialFocusRef,\r\n  enabled,\r\n}: {\r\n  targetRef: React.RefObject<HTMLElement>\r\n  fallbackRef: React.RefObject<HTMLElement>\r\n  initialFocusRef?: React.RefObject<HTMLElement>\r\n  enabled: boolean\r\n}) {\r\n  const ref = useRef<{ activate: () => void; deactivate: () => void }>({\r\n    activate: () => {\r\n      throw new TypeError('Tried to activate focus trap too early')\r\n    },\r\n    deactivate: () => {},\r\n  })\r\n\r\n  useDebugValue(enabled ? 'Enabled' : 'Disabled')\r\n\r\n  useEffect(() => {\r\n    if (!enabled) {\r\n      ref.current.deactivate()\r\n      ref.current = { activate: () => {}, deactivate: () => {} }\r\n      return\r\n    }\r\n\r\n    const fallback = fallbackRef.current\r\n    const trap = createFocusTrap(targetRef.current, {\r\n      onActivate:\r\n        process.env.NODE_ENV !== 'production'\r\n          ? () => {\r\n              console.log('focus activate')\r\n            }\r\n          : undefined,\r\n      // If initialFocusRef is manually specified we don't want the first tabbable element to receive focus if initialFocusRef can't be found\r\n      initialFocus: initialFocusRef\r\n        ? () => initialFocusRef?.current || fallback\r\n        : undefined,\r\n      fallbackFocus: fallback,\r\n      escapeDeactivates: false,\r\n      clickOutsideDeactivates: false,\r\n    })\r\n    let active = false\r\n\r\n    ref.current = {\r\n      activate: async () => {\r\n        if (active) return\r\n        active = true\r\n\r\n        await trap.activate()\r\n        // it's difficult to know exactly when focus is udpated https://github.com/focus-trap/focus-trap/blob/036a72ec48b85414dda00ec0c40d631c8f0ae5ce/index.js#L369-L371\r\n        // This timeout is attempting to compromise between a reasonable guess, as well as not delaying the open transition more than necessary\r\n        await new Promise((resolve) => setTimeout(() => resolve(void 1), 0))\r\n      },\r\n      deactivate: () => {\r\n        if (!active) return\r\n        active = false\r\n\r\n        trap.deactivate()\r\n      },\r\n    }\r\n  }, [enabled, fallbackRef, initialFocusRef, targetRef])\r\n\r\n  return ref\r\n}\r\n","import { interpolate } from 'react-spring'\r\nimport type { Spring } from './useSpring'\r\nimport { clamp } from '../utils'\r\n\r\n// It's a bit easier to ensure interpolations don't accidentally use the wrong variables by\r\n// putting them here, in their own closure with explicitly defined variables used\r\n\r\n// Note that the callbacks in the interpolation functions close over their scope every time react renders\r\n// so it's important that if anything can change outside of render that needs to be available\r\n// in the interpolation then a ref must be used\r\n\r\nexport function useSpringInterpolations({\r\n  spring,\r\n}: {\r\n  spring: Spring\r\n}): React.CSSProperties {\r\n  // This effect is for removing rounded corners on phones when the sheet touches the top of the browser chrome\r\n  // as it's really ugly with the gaps border radius creates. This ensures it looks sleek.\r\n  // @TODO the ts-ignore comments are because the `extrapolate` param isn't in the TS defs for some reason\r\n  const interpolateBorderRadius = interpolate(\r\n    // @ts-expect-error\r\n    [spring.y, spring.maxHeight, spring.topOffset],\r\n    (y, maxHeight, topOffset) => {\r\n      return `${Math.round(clamp(maxHeight - y - (topOffset || 0), 0, 16))}px`\r\n    }\r\n  )\r\n\r\n  /*\r\n   * Only animate the height when absolute necessary\r\n   * @TODO currently it's only able to opt out of changing the height if there's just a single snapshot\r\n   *       but it should be possible to do it in other scenarios too, like on window resize,\r\n   *       or maybe even while dragging, but probably requires a more restrictive CSS.\r\n   *       As in now the sticky footer isn't overlapping the content, allowing `backdrop-filter: blur(8px)` effects.\r\n   *       A FLIP resize flow for content height would likely require the sticky elements to overlap the content area.\r\n   *       Could be done as a separat mode though, or a separate example CSS for max performance.\r\n   */\r\n  const interpolateHeight = interpolate(\r\n    // @ts-ignore\r\n    [spring.y, spring.minSnap, spring.maxSnap],\r\n    (y, minSnap, maxSnap) => `${clamp(y, minSnap, maxSnap)}px`\r\n  )\r\n\r\n  const interpolateY = interpolate(\r\n    // @ts-ignore\r\n    [spring.y, spring.minSnap, spring.maxSnap],\r\n    (y, minSnap, maxSnap) => {\r\n      if (y < minSnap) {\r\n        return `${minSnap - y}px`\r\n      }\r\n      if (y > maxSnap) {\r\n        return `${maxSnap - y}px`\r\n      }\r\n      return '0px'\r\n    }\r\n  )\r\n\r\n  const interpolateFiller = interpolate(\r\n    // @ts-ignore\r\n    [spring.y, spring.maxSnap],\r\n    (y, maxSnap) => {\r\n      if (y >= maxSnap) {\r\n        return Math.ceil(y - maxSnap)\r\n      }\r\n      return 0\r\n    }\r\n  )\r\n\r\n  const interpolateContentOpacity = interpolate(\r\n    // @ts-ignore\r\n    [spring.y, spring.minSnap],\r\n    (y, minSnap) => {\r\n      if (!minSnap) {\r\n        return 0\r\n      }\r\n      const minX = Math.max(minSnap / 2 - 45, 0)\r\n      const maxX = Math.min(minSnap / 2 + 45, minSnap)\r\n      const minY = 0\r\n      const maxY = 1\r\n\r\n      const slope = (maxY - minY) / (maxX - minX)\r\n      const res = (y - minX) * (slope + minY)\r\n      return clamp(res, 0, 1)\r\n    }\r\n  )\r\n\r\n  const interpolateBackdrop = interpolate(\r\n    // @ts-ignore\r\n    [spring.y, spring.minSnap],\r\n    (y, minSnap) => (minSnap ? clamp(y / minSnap, 0, 1) : 0)\r\n  )\r\n\r\n  return {\r\n    // Fancy content fade-in effect\r\n    ['--rsbs-content-opacity' as any]: interpolateContentOpacity,\r\n    // Fading in the backdrop\r\n    ['--rsbs-backdrop-opacity' as any]: interpolateBackdrop,\r\n    // Scaling the antigap in the bottom\r\n    ['--rsbs-antigap-scale-y' as any]: interpolateFiller,\r\n    // Shifts the position of the bottom sheet, used on open and close primarily as snap point changes usually only interpolate the height\r\n    ['--rsbs-overlay-translate-y' as any]: interpolateY,\r\n    // Remove rounded borders when full height, it looks much better this way\r\n    ['--rsbs-overlay-rounded' as any]: interpolateBorderRadius,\r\n    // Animates the height state, not the most performant way but it's the safest with regards to mobile browser and focus/scrolling that could happen while animating\r\n    ['--rsbs-overlay-h' as any]: interpolateHeight,\r\n  }\r\n}\r\n","/* eslint-disable react/jsx-pascal-case */\r\nimport Portal from '@reach/portal'\r\nimport React, { forwardRef, useRef, useState, useCallback } from 'react'\r\nimport { BottomSheet as _BottomSheet } from './BottomSheet'\r\nimport type { Props, RefHandles, SpringEvent } from './types'\r\nimport { useLayoutEffect } from './hooks'\r\n\r\nexport type {\r\n  RefHandles as BottomSheetRef,\r\n  Props as BottomSheetProps,\r\n} from './types'\r\n\r\n// Because SSR is annoying to deal with, and all the million complaints about window, navigator and dom elenents!\r\nexport const BottomSheet = forwardRef<RefHandles, Props>(function BottomSheet(\r\n  { onSpringStart, onSpringEnd, skipInitialTransition, ...props },\r\n  ref\r\n) {\r\n  // Mounted state, helps SSR but also ensures you can't tab into the sheet while it's closed, or nav there in a screen reader\r\n  const [mounted, setMounted] = useState(false)\r\n  const timerRef = useRef<ReturnType<typeof requestAnimationFrame>>()\r\n  // The last point that the user snapped to, useful for open/closed toggling and the user defined height is remembered\r\n  const lastSnapRef = useRef(null)\r\n  // @TODO refactor to an initialState: OPEN | CLOSED property as it's much easier to understand\r\n  // And informs what we should animate from. If the sheet is mounted with open = true, then initialState = OPEN.\r\n  // When initialState = CLOSED, then internal sheet must first render with open={false} before setting open={props.open}\r\n  // It's only when initialState and props.open is mismatching that a intial transition should happen\r\n  // If they match then transitions will only happen when a user interaction or resize event happen.\r\n  const initialStateRef = useRef<'OPEN' | 'CLOSED'>(\r\n    skipInitialTransition && props.open ? 'OPEN' : 'CLOSED'\r\n  )\r\n\r\n  // Using layout effect to support cases where the bottom sheet have to appear already open, no transition\r\n  useLayoutEffect(() => {\r\n    if (props.open) {\r\n      cancelAnimationFrame(timerRef.current)\r\n      setMounted(true)\r\n\r\n      // Cleanup defaultOpen state on close\r\n      return () => {\r\n        initialStateRef.current = 'CLOSED'\r\n      }\r\n    }\r\n  }, [props.open])\r\n\r\n  const handleSpringStart = useCallback(\r\n    async function handleSpringStart(event: SpringEvent) {\r\n      // Forward the event\r\n      await onSpringStart?.(event)\r\n\r\n      if (event.type === 'OPEN') {\r\n        // Ensures that when it's opening we abort any pending unmount action\r\n        cancelAnimationFrame(timerRef.current)\r\n      }\r\n    },\r\n    [onSpringStart]\r\n  )\r\n\r\n  const handleSpringEnd = useCallback(\r\n    async function handleSpringEnd(event: SpringEvent) {\r\n      // Forward the event\r\n      await onSpringEnd?.(event)\r\n\r\n      if (event.type === 'CLOSE') {\r\n        // Unmount from the dom to avoid contents being tabbable or visible to screen readers while closed\r\n        timerRef.current = requestAnimationFrame(() => setMounted(false))\r\n      }\r\n    },\r\n    [onSpringEnd]\r\n  )\r\n\r\n  // This isn't just a performance optimization, it's also to avoid issues when running a non-browser env like SSR\r\n  if (!mounted) {\r\n    return null\r\n  }\r\n\r\n  return (\r\n    <Portal data-rsbs-portal>\r\n      <_BottomSheet\r\n        {...props}\r\n        lastSnapRef={lastSnapRef}\r\n        ref={ref}\r\n        initialState={initialStateRef.current}\r\n        onSpringStart={handleSpringStart}\r\n        onSpringEnd={handleSpringEnd}\r\n      />\r\n    </Portal>\r\n  )\r\n})\r\n"],"names":["useLayoutEffect","window","useLayoutEffectSafely","useEffect","hasPassiveEvents","passiveTestOptions","passive","addEventListener","removeEventListener","isIosDevice","navigator","platform","test","maxTouchPoints","previousBodyOverflowSetting","previousBodyPaddingRight","locks","documentListenerAdded","initialClientY","allowTouchMove","el","some","lock","options","preventDefault","rawEvent","e","event","target","touches","length","restoreOverflowSetting","undefined","document","body","style","paddingRight","overflow","isTargetElementTotallyScrolled","targetElement","scrollHeight","scrollTop","clientHeight","clamp","number","lower","upper","roundAndCheckForNaN","unrounded","rounded","Math","round","Number","isNaN","TypeError","observerOptions","box","useElementSizeObserver","ref","label","enabled","resizeSourceRef","size","setSize","useState","useDebugValue","handleResize","useCallback","entries","borderBoxSize","blockSize","current","resizeObserver","ResizeObserver","observe","disconnect","sleep","ms","Promise","resolve","setTimeout","openToDrag","DRAG","actions","openToResize","RESIZE","overlayMachine","Machine","id","initial","context","initialState","states","closed","on","OPEN","CLOSE","opening","start","invoke","src","onDone","transition","always","cond","immediately","open","activating","smoothly","visuallyHidden","end","done","type","SNAP","dragging","snapping","entry","assign","y","_","payload","velocity","snapSource","source","snappingSmoothly","resizing","resizingSmoothly","closing","deactivating","closingSmoothly","onOpenCancel","onSnapCancel","onResizeCancel","onCloseCancel","onOpenEnd","onSnapEnd","onRezizeEnd","services","onSnapStart","async","onOpenStart","onCloseStart","onResizeStart","onCloseEnd","onResizeEnd","renderVisuallyHidden","activate","deactivate","openSmoothly","openImmediately","snapSmoothly","resizeSmoothly","closeSmoothly","guards","initiallyClosed","initiallyOpen","tension","friction","config","default","BottomSheet","React","forwardRef","children","sibling","className","topOffset","springConfig","ignoreLockClasses","footer","header","_open","lastSnapRef","initialFocusRef","onDismiss","maxHeight","controlledMaxHeight","defaultSnap","getDefaultSnap","_defaultSnap","snapPoints","getSnapPoints","_snapPoints","blocking","scrollLocking","onSpringStart","onSpringCancel","onSpringEnd","reserveScrollBarGap","props","ready","registerReady","setReady","readyMap","updateReadyMap","key","[object Object]","Object","values","every","Boolean","useReady","canDragRef","useRef","onSpringStartRef","onSpringCancelRef","onSpringEndRef","spring","set","useReactSpring","minSnap","maxSnap","containerRef","scrollRef","contentRef","headerRef","footerRef","overlayRef","heightRef","prefersReducedMotion","mql","useMemo","matchMedia","matches","handler","addListener","removeListener","useReducedMotion","scrollLockRef","targetRef","active","forEach","ontouchstart","ontouchmove","targetTouches","clientY","stopPropagation","handleScroll","scrollBarGap","innerWidth","documentElement","clientWidth","computedBodyPaddingRight","parseInt","getComputedStyle","getPropertyValue","setOverflowHidden","disableBodyScroll","closest","filter","useScrollLock","Array","isArray","ariaHiderRef","originalValues","rootNodes","parentNode","querySelectorAll","node","attr","getAttribute","push","setAttribute","index","originalValue","removeAttribute","useAriaHider","focusTrapRef","fallbackRef","fallback","trap","createFocusTrap","onActivate","initialFocus","fallbackFocus","escapeDeactivates","clickOutsideDeactivates","useFocusTrap","findSnap","footerEnabled","headerEnabled","minHeight","headerHeight","footerHeight","setMaxHeight","innerHeight","raf","requestAnimationFrame","cancelAnimationFrame","useMaxHeight","contentHeight","min","useDimensions","unsafeSnaps","snapPointsDedupedSet","concat","map","reduce","acc","snapPoint","add","Set","from","max","processSnapPoints","height","numberOrCallback","unsafeSearch","lastSnap","querySnap","prev","curr","abs","useSnapPoints","maxHeightRef","minSnapRef","maxSnapRef","findSnapRef","defaultSnapRef","topOffsetRef","asyncSet","_ref2","onRest","opts","mass","args","send","useMachine","devTools","immediate","all","snap","useImperativeHandle","snapTo","bind","useDrag","closeOnTap","cancel","direction","down","first","last","memo","getValue","movement","_my","tap","my","rawY","predictedDistance","predictedY","newY","rubberbandIfOutOfBounds","filterTaps","interpolations","interpolateBorderRadius","interpolate","interpolateHeight","interpolateY","interpolateFiller","ceil","--rsbs-content-opacity","minX","--rsbs-backdrop-opacity","--rsbs-antigap-scale-y","--rsbs-overlay-translate-y","--rsbs-overlay-rounded","--rsbs-overlay-h","useSpringInterpolations","animated","div","data-rsbs-root","data-rsbs-state","publicStates","find","data-rsbs-is-blocking","data-rsbs-is-dismissable","data-rsbs-has-header","data-rsbs-has-footer","opacity","data-rsbs-backdrop","aria-modal","role","data-rsbs-overlay","tabIndex","onKeyDown","data-rsbs-header","data-rsbs-scroll","data-rsbs-content","data-rsbs-footer","skipInitialTransition","mounted","setMounted","timerRef","initialStateRef","handleSpringStart","handleSpringEnd","Portal","data-rsbs-portal","_BottomSheet"],"mappings":"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"}